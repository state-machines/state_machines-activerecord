# frozen_string_literal: true

require 'state_machines-activemodel'
require 'active_record'
require 'active_support/concern'
require 'state_machines/integrations/active_record/version'

module StateMachines
  module Integrations # :nodoc:
    # ActiveRecord integration for state machines with Rails 7.2+ enum support.
    #
    # @example Basic usage
    #   class Vehicle < ApplicationRecord
    #     enum status: { parked: 0, idling: 1 }
    #     state_machine :status, initial: :parked do
    #       event :ignite do
    #         transition parked: :idling
    #       end
    #     end
    #   end
    module ActiveRecord
      include Base
      include ActiveModel

      # The default options to use for state machines using this integration
      @defaults = { action: :save, use_transactions: true }

      # Modern enum integration using Rails' built-in enum capabilities
      def after_initialize
        super
        patch_enum_once if enum_integrated?
      end

      # Check if this machine has enum integration enabled
      def enum_integrated?
        owner_class.defined_enums.key?(attribute.to_s)
      end

      # Get the enum mapping for this attribute
      def enum_mapping
        return {} unless enum_integrated?

        @enum_mapping ||= owner_class.defined_enums[attribute.to_s] || {}
      end

      # Get list of original enum methods that were preserved
      def original_enum_methods
        return [] unless enum_integrated?

        enum_mapping.keys.flat_map do |value|
          [
            "#{value}?",
            "#{value}!",
            value.to_s,
            "not_#{value}"
          ]
        end.select { |method| owner_class.method_defined?(method) || owner_class.respond_to?(method) }
      end

      # Get list of state machine methods that were generated by Rails enum
      def state_machine_methods
        return [] unless enum_integrated?

        enum_mapping.keys.flat_map do |value|
          [
            "#{attribute}_#{value}?",
            "#{attribute}_#{value}!",
            "#{attribute}_#{value}"
          ]
        end.select { |method| owner_class.method_defined?(method) || owner_class.respond_to?(method) }
      end

      # Generate method name for enum integration compatibility
      def generate_state_method_name(state, type)
        case type
        when :predicate
          "#{attribute}_#{state}?"
        when :bang
          "#{attribute}_#{state}!"
        when :scope
          "#{attribute}_#{state}"
        else
          "#{attribute}_#{state}"
        end
      end

      # Enum integration configuration (for backward compatibility)
      def enum_integration
        {
          prefix: true,
          suffix: false,
          validate: true,
          scopes: true
        }
      end

      private

      # Patch enum integration once per class using singleton instance variable
      def patch_enum_once
        return if owner_class.singleton_class.instance_variable_defined?(:@enum_patched)
        return if enum_mapping.empty?

        # If enum is not yet defined, create it with prefix
        unless owner_class.defined_enums.key?(attribute.to_s)
          owner_class.enum({ attribute => enum_mapping }, prefix: true)
        else
          # If enum already exists without prefix, add prefixed methods manually
          add_prefixed_enum_methods
        end

        # Add not_ scopes for each state
        enum_mapping.each do |state, stored_value|
          machine_attr = attribute
          scope_name = "not_#{attribute}_#{state}"
          unless owner_class.respond_to?(scope_name)
            owner_class.scope scope_name, -> { where.not(machine_attr => stored_value) }
          end
        end

        owner_class.singleton_class.instance_variable_set(:@enum_patched, true)
      end

      # Add prefixed methods when enum already exists without prefix
      def add_prefixed_enum_methods
        enum_mapping.each do |state, _stored_value|
          prefix = "#{attribute}_"
          
          # Predicate methods (status_pending?)
          predicate_method = "#{prefix}#{state}?"
          unless owner_class.method_defined?(predicate_method)
            owner_class.define_method(predicate_method) do
              public_send("#{state}?")
            end
          end
          
          # Bang methods (status_pending!) - raise error for enum conflict resolution
          bang_method = "#{prefix}#{state}!"
          unless owner_class.method_defined?(bang_method)
            method_name = bang_method
            owner_class.define_method(bang_method) do
              # These prefixed methods exist for conflict resolution but should not be used directly
              # They exist to avoid conflicts with the original enum methods, but are not functional
              raise RuntimeError, "Cannot use prefixed enum bang method #{method_name} directly. Use events instead."
            end
          end
          
          # Scope methods (status_pending)
          scope_method = "#{prefix}#{state}"
          unless owner_class.respond_to?(scope_method)
            owner_class.define_singleton_method(scope_method) do
              public_send(state.to_s)
            end
          end
        end
      end

      class << self
        # Classes that inherit from ActiveRecord::Base will automatically use
        # the ActiveRecord integration.
        def matching_ancestors
          [::ActiveRecord::Base]
        end
      end

      protected

      # Modern ActiveSupport::Concern for state machine integration
      module InstanceMethods
        extend ActiveSupport::Concern

        included do
          around_save :_run_state_machine_callbacks
        end

        def initialize(attrs = nil, **kw, &block)
          super(attrs, **kw) do |*args|
            # Handle attribute aliases like Rails does
            processed_attrs = (attrs || {}).transform_keys { |key|
              self.class.attribute_aliases[key.to_s] || key.to_s
            } if attrs.respond_to?(:transform_keys) && self.class.respond_to?(:attribute_aliases)
            
            processed_attrs ||= (attrs || {})
            scoped_attrs = processed_attrs.merge(self.class.scope_attributes || {})
            
            self.class.state_machines.initialize_states(self, {}, scoped_attrs)
            yield(*args) if block_given?
          end
        end

        private

        def _run_state_machine_callbacks(&block)
          # Skip if callbacks are temporarily disabled
          return yield if @_state_machine_callbacks_disabled

          self.class.state_machines.transitions(self, :save).perform(&block)
        end
        
        
        # Track whether a transition is already in progress for this instance
        def _state_machine_transitioning?
          !!@_state_machine_transitioning
        end
        
        # Temporarily disable state machine callbacks during direct transitions
        def with_disabled_state_machine_callbacks
          was_disabled = @_state_machine_callbacks_disabled
          @_state_machine_callbacks_disabled = true
          begin
            yield
          ensure
            @_state_machine_callbacks_disabled = was_disabled
          end
        end
        
        def _state_machine_callbacks_disabled?
          !!@_state_machine_callbacks_disabled
        end
      end

      protected

      # Do validations run when the action configured this machine is
      # invoked?  This is used to determine whether to fire off attribute-based
      # event transitions when the action is run.
      def runs_validations_on_action?
        action == :save
      end

      def define_state_initializer
        # State initialization now handled by InstanceMethods concern
      end

      def define_action_hook
        owner_class.include InstanceMethods unless owner_class < InstanceMethods
        
        
        # Define autosave support using define_helper for proper method access
        define_helper :instance, <<-END_EVAL, __FILE__, __LINE__ + 1
          def changed_for_autosave?
            super || self.class.state_machines.any? { |_name, machine| 
              machine.action == :save && public_send(machine.attribute(:event)) rescue false
            }
          end
        END_EVAL
        
        # For custom actions, we need to define the method hook
        if action != :save
          action_name = action
          machine_name = name
          owner_class.define_method(action_name) do |*args, **kwargs, &block|
            self.class.state_machine(machine_name).around_save(self) { super(*args, **kwargs, &block) }
          end
        end
      end

      public

      # Runs state events around the machine's :save action
      def around_save(object, &)
        object.class.state_machines.transitions(object, action).perform(&)
      end
      
      # Wraps the given block in a database transaction
      def transaction(object)
        object.class.transaction do
          if result = yield
            result
          else
            raise ::ActiveRecord::Rollback
          end
        end
      end
      

      # No longer needed - callbacks handled in InstanceMethods

      protected

      # Creates scopes for finding records with/without specific states
      def create_with_scope(name)
        attr_name = attribute
        lambda do |klass, *states|
          if states.compact.empty?
            klass.all
          else
            # Get the machine for this class (which may be a subclass with different states)
            machine = klass.state_machine(attr_name)
            # Convert state names to their stored values using the class's machine
            values = states.flatten.compact.map { |state| 
              machine.states.fetch(state).value if machine.states[state]
            }.compact
            values.empty? ? klass.none : klass.where(attr_name => values)
          end
        end
      end

      def create_without_scope(name)
        attr_name = attribute  
        lambda do |klass, *states|
          if states.compact.empty?
            klass.all
          else
            # Get the machine for this class (which may be a subclass with different states)
            machine = klass.state_machine(attr_name)
            # Convert state names to their stored values using the class's machine
            values = states.flatten.compact.map { |state| 
              machine.states.fetch(state).value if machine.states[state]
            }.compact
            values.empty? ? klass.all : klass.where.not(attr_name => values)
          end
        end
      end

      def locale_path
        "#{File.dirname(__FILE__)}/active_record/locale.rb"
      end

      # Adds hooks into validation for automatically firing events  
      def define_action_helpers
        super
        # Callbacks are handled by the InstanceMethods concern
      end

      private

      # Generates scope results based on states to filter by
      def run_scope(scope, machine, klass, states)
        scope.call(klass, *states)
      end
    end
    register(ActiveRecord)
  end
end
